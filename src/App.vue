<template>
  <div id="app">
    <h1>{{ headerText }}</h1>
    <p>{{ currentTurn }}'s turn</p>
    <div class="boardHolder">
      <div class="board">
        <div v-for="(row, rowIndex) in boardArray">
          <div class="row" v-bind:key="rowIndex">
            <div v-for="(square, squareIndex) in row">
              <Square :piece="square.piece" :row="square.row" :column="square.column" />
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>




<script>
//component imports
import Square from "./components/Square.vue";
//import func from '../vue-temp/vue-editor-bridge'; I don't know where this line of code came from, it wasn't in the autogenerated empty project and I didn't put it here

export default {
  name: "app",
  components: {
    Square
  },

  methods: {
    /**
     * Sets a piece on the board based on whose turn it is. Will flip any pieces that need to be flipped
     */
    setPiece: function(event, piece, row, column) {
      //first, we have to check if a piece can be set here. A piece can't be set if a piece is already here, or if placing a piece here wouldn't do flip anything

      console.log("===========================");
      console.log("a piece is attempting to be set");
      console.log(
        "It is currently " + piece + ` at coordinates = (${column},${row})`
      );
      if (piece === null) {
        this.boardArray[row][column].piece =
          this.currentTurn === "White" ? "white" : "black";
        //console.log(this.boardArray[row][column]);
        this.currentTurn = this.currentTurn === "White" ? "Black" : "White";
        console.log("new piece value is " + this.boardArray[row][column].piece);
      } else console.log("There is already a piece on this square");

      //now that a piece is set, we have to check for surrounding pieces. There are 8 possible directions to check for.
      //remember the pieces in the array are organized into this.boardArray[row][column]
      let piecesToBeFlipped = [];

      //FIXME: Line 46 switches the turns early. Once that is moved, swap the two white and black conditionals around
      let opponentPieceColor = this.currentTurn === "White" ? "white" : "black"; //if our piece is white, opponent piece is black and vice versa
      let myColor = this.currentTurn === "White" ? "black" : "white";

      //checking UP
      for (let i = row - 1; i >= 0; i--) {
        console.log("checking above row = " + (i + 1) + " column = " + column);
        if (this.boardArray[i][column].piece === opponentPieceColor) {
          //if the piece above is not my color
          console.log(
            "piece above was " +
              opponentPieceColor +
              ` at (${this.boardArray[i][column].column},${this.boardArray[i][column].row}). Adding it to the pieces to be flipped`
          );
          piecesToBeFlipped.push({ row: i, column: column }); //get it ready to be flipped, add it to the array
        } else if (this.boardArray[i][column].piece === myColor) {
          //if the piece above is equal to my color,
          console.log(
            `piece above is ${myColor} at row ${i} column ${column}. flipping array`
          );
          console.log(`Flipping ${piecesToBeFlipped.length} pieces...`);
          console.log(piecesToBeFlipped);
          piecesToBeFlipped.forEach(element => {
            //flip all the pieces in the array that are not my color ie. the ones in between two pieces of my color
            console.log("the element being flipped - ");
            console.log(this.boardArray[element.row][element.column]);
            console.log("setting it to be " + piece);
            this.boardArray[element.row][element.column].piece = myColor;
          });
          break; //break, you already flipped everything here you need to
        } else if (this.boardArray[i][column].piece === null) {
          console.log(
            "piece above was null at row = " + i + ", column = " + column
          );
          break; //if you reached a null piece without first reaching your own piece, break and don't flip
        }
      }
      piecesToBeFlipped = [];

      //EACH CHECK IS BASED ON THE FIRST, SO CONSOLE LOGS ARE REMOVED FOR THE SAKE OF READABILITY

      //checking DOWN
      for (let i = row + 1; i <= 7; i++) {
        if (this.boardArray[i][column].piece === opponentPieceColor) {
          //if the piece below is not my color
          piecesToBeFlipped.push({ row: i, column: column }); //get it ready to be flipped, add it to the array
        } else if (this.boardArray[i][column].piece === myColor) {
          //if the piece below is equal to my color,
          piecesToBeFlipped.forEach(element => {
            //flip all the pieces in the array that are not my color ie. the ones in between two pieces of my color
            this.boardArray[element.row][element.column].piece = myColor;
          });
          break; //break, you already flipped everything here you need to
        } else if (this.boardArray[i][column].piece === null) {
          break; //if you reached a null piece without first reaching your own piece, break and don't flip
        }
      }
      piecesToBeFlipped = [];

      //checking LEFT
      for (let i = column - 1; i >= 0; i--) {
        if (this.boardArray[row][i].piece === opponentPieceColor) {
          //if the piece to the left is not my color
          piecesToBeFlipped.push({ row: row, column: i }); //get it ready to be flipped, add it to the array
        } else if (this.boardArray[row][i].piece === myColor) {
          //if the piece to the left is equal to my color,
          piecesToBeFlipped.forEach(element => {
            //flip all the pieces in the array that are not my color ie. the ones in between two pieces of my color
            this.boardArray[element.row][element.column].piece = myColor;
          });
          break; //break, you already flipped everything here you need to
        } else if (this.boardArray[row][i].piece === null) {
          break; //if you reached a null piece without first reaching your own piece, break and don't flip
        }
      }
      piecesToBeFlipped = [];


      //checking RIGHT
      for (let i = column + 1; i <= 7; i++) {
        if (this.boardArray[row][i].piece === opponentPieceColor) {
          //if the piece to the right is not my color
          piecesToBeFlipped.push({ row: row, column: i }); //get it ready to be flipped, add it to the array
        } else if (this.boardArray[row][i].piece === myColor) {
          //if the piece to the right is equal to my color,
          piecesToBeFlipped.forEach(element => {
            //flip all the pieces in the array that are not my color ie. the ones in between two pieces of my color
            this.boardArray[element.row][element.column].piece = myColor;
          });
          break; //break, you already flipped everything here you need to
        } else if (this.boardArray[row][i].piece === null) {
          break; //if you reached a null piece without first reaching your own piece, break and don't flip
        }
      }
      piecesToBeFlipped = [];
    },/************************************************************************************************************************************END OF SET PIECE */
    
    /**
     * Checks the status of the game every turn to see if its finished
     */
    checkGameStatus: function() {

    }
  },

  data() {
    return {
      headerText: "Othello",
      currentTurn: Math.random() > 0.5 ? "Black" : "White",
      boardArray: []
    };
  },

  //run when board is created
  created: function() {
    //generate board array
    for (let i = 0; i <= 7; i++) {
      let rowArray = [];
      for (let j = 0; j <= 7; j++) {
        rowArray.push({ id: 1, row: i, column: j, piece: null });
      }
      //console.log(rowArray);
      this.boardArray.push(rowArray);
    }

    //Now, set the starting pieces
    this.boardArray[3][3].piece = "white";
    this.boardArray[4][3].piece = "black";
    this.boardArray[3][4].piece = "black";
    this.boardArray[4][4].piece = "white";
  }
};
</script>

<style>
#app {
  font-family: "Avenir", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}

h1,
h2 {
  font-weight: normal;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  display: inline-block;
  margin: 0 10px;
}

a {
  color: #42b983;
}

.boardHolder {
  display: flex;
  align-items: center;
  flex-direction: column;
}

.board {
  border: 1em solid black;
}

.row {
  display: flex;
  flex-direction: row;
}
</style>
